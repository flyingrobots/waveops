name: Infrastructure Management

on:
  push:
    branches: [ main, develop ]
    paths: 
      - 'deployment/terraform/**'
      - 'deployment/helm/**'
      - 'deployment/kubernetes/**'
  pull_request:
    branches: [ main, develop ]
    paths: 
      - 'deployment/terraform/**'
      - 'deployment/helm/**'
      - 'deployment/kubernetes/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - staging
          - production
      action:
        description: 'Action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
          - destroy
      auto_approve:
        description: 'Auto approve changes'
        required: false
        default: false
        type: boolean

env:
  TERRAFORM_VERSION: '1.5.7'
  HELM_VERSION: 'v3.13.0'

jobs:
  # Terraform Plan
  terraform-plan:
    name: Terraform Plan (${{ github.event.inputs.environment || 'all' }})
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: ${{ github.event.inputs.environment && fromJSON(format('["{0}"]', github.event.inputs.environment)) || fromJSON('["development", "staging", "production"]') }}
    
    outputs:
      plan-exists: ${{ steps.plan.outputs.exitcode == 2 }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets[format('AWS_ACCESS_KEY_ID_{0}', upper(matrix.environment))] }}
        aws-secret-access-key: ${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', upper(matrix.environment))] }}
        aws-region: ${{ secrets[format('AWS_REGION_{0}', upper(matrix.environment))] }}
        
    - name: Terraform Init
      id: init
      run: |
        cd deployment/terraform
        terraform init \
          -backend-config="bucket=${{ secrets[format('TF_STATE_BUCKET_{0}', upper(matrix.environment))] }}" \
          -backend-config="key=waveops/${{ matrix.environment }}/terraform.tfstate" \
          -backend-config="region=${{ secrets[format('AWS_REGION_{0}', upper(matrix.environment))] }}" \
          -backend-config="dynamodb_table=${{ secrets[format('TF_LOCK_TABLE_{0}', upper(matrix.environment))] }}"
          
    - name: Terraform Plan
      id: plan
      run: |
        cd deployment/terraform
        terraform plan \
          -var-file="environments/${{ matrix.environment }}.tfvars" \
          -out=${{ matrix.environment }}.tfplan \
          -no-color
      continue-on-error: true
      
    - name: Save Terraform Plan
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plan-${{ matrix.environment }}
        path: deployment/terraform/${{ matrix.environment }}.tfplan
        retention-days: 7
        
    - name: Comment PR with Terraform Plan
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const planOutput = `${{ steps.plan.outputs.stdout }}`;
          
          const output = `#### Terraform Plan Results for \`${{ matrix.environment }}\` 
          \`\`\`diff
          ${planOutput}
          \`\`\`
          
          *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`, Environment: \`${{ matrix.environment }}\`*`;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: output
          });

  # Terraform Apply
  terraform-apply:
    name: Terraform Apply (${{ matrix.environment }})
    runs-on: ubuntu-latest
    needs: terraform-plan
    if: |
      (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply') ||
      (github.ref == 'refs/heads/main' && github.event_name == 'push')
    strategy:
      matrix:
        environment: ${{ github.event.inputs.environment && fromJSON(format('["{0}"]', github.event.inputs.environment)) || fromJSON('["development"]') }}
    environment:
      name: ${{ matrix.environment }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        terraform_wrapper: false
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets[format('AWS_ACCESS_KEY_ID_{0}', upper(matrix.environment))] }}
        aws-secret-access-key: ${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', upper(matrix.environment))] }}
        aws-region: ${{ secrets[format('AWS_REGION_{0}', upper(matrix.environment))] }}
        
    - name: Download Terraform Plan
      uses: actions/download-artifact@v4
      with:
        name: terraform-plan-${{ matrix.environment }}
        path: deployment/terraform/
        
    - name: Terraform Init
      run: |
        cd deployment/terraform
        terraform init \
          -backend-config="bucket=${{ secrets[format('TF_STATE_BUCKET_{0}', upper(matrix.environment))] }}" \
          -backend-config="key=waveops/${{ matrix.environment }}/terraform.tfstate" \
          -backend-config="region=${{ secrets[format('AWS_REGION_{0}', upper(matrix.environment))] }}" \
          -backend-config="dynamodb_table=${{ secrets[format('TF_LOCK_TABLE_{0}', upper(matrix.environment))] }}"
          
    - name: Terraform Apply
      id: apply
      run: |
        cd deployment/terraform
        if [ "${{ github.event.inputs.auto_approve }}" = "true" ] || [ "${{ github.event_name }}" = "push" ]; then
          terraform apply -auto-approve ${{ matrix.environment }}.tfplan
        else
          echo "Manual approval required"
          exit 1
        fi
        
    - name: Save Terraform Outputs
      run: |
        cd deployment/terraform
        terraform output -json > outputs-${{ matrix.environment }}.json
        
    - name: Upload Terraform Outputs
      uses: actions/upload-artifact@v4
      with:
        name: terraform-outputs-${{ matrix.environment }}
        path: deployment/terraform/outputs-${{ matrix.environment }}.json

  # Helm Chart Validation and Deployment
  helm-deployment:
    name: Helm Deployment (${{ matrix.environment }})
    runs-on: ubuntu-latest
    needs: terraform-apply
    if: always() && (needs.terraform-apply.result == 'success' || needs.terraform-apply.result == 'skipped')
    strategy:
      matrix:
        environment: ${{ github.event.inputs.environment && fromJSON(format('["{0}"]', github.event.inputs.environment)) || fromJSON('["development"]') }}
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Helm
      uses: azure/setup-helm@v4
      with:
        version: ${{ env.HELM_VERSION }}
        
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets[format('AWS_ACCESS_KEY_ID_{0}', upper(matrix.environment))] }}
        aws-secret-access-key: ${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', upper(matrix.environment))] }}
        aws-region: ${{ secrets[format('AWS_REGION_{0}', upper(matrix.environment))] }}
        
    - name: Download Terraform Outputs
      uses: actions/download-artifact@v4
      with:
        name: terraform-outputs-${{ matrix.environment }}
        path: ./
        
    - name: Extract cluster information
      id: cluster-info
      run: |
        CLUSTER_NAME=$(jq -r '.cluster_id.value' outputs-${{ matrix.environment }}.json)
        CLUSTER_ENDPOINT=$(jq -r '.cluster_endpoint.value' outputs-${{ matrix.environment }}.json)
        echo "cluster-name=${CLUSTER_NAME}" >> $GITHUB_OUTPUT
        echo "cluster-endpoint=${CLUSTER_ENDPOINT}" >> $GITHUB_OUTPUT
        
    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig \
          --region ${{ secrets[format('AWS_REGION_{0}', upper(matrix.environment))] }} \
          --name ${{ steps.cluster-info.outputs.cluster-name }}
          
    - name: Validate Helm Chart
      run: |
        helm lint deployment/helm/waveops
        helm template waveops deployment/helm/waveops \
          --values deployment/helm/waveops/values-${{ matrix.environment }}.yaml \
          --dry-run --debug > helm-rendered-${{ matrix.environment }}.yaml
          
    - name: Upload rendered Helm templates
      uses: actions/upload-artifact@v4
      with:
        name: helm-rendered-${{ matrix.environment }}
        path: helm-rendered-${{ matrix.environment }}.yaml
        
    - name: Deploy with Helm
      run: |
        # Add helm repositories
        helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
        helm repo add grafana https://grafana.github.io/helm-charts
        helm repo add jaegertracing https://jaegertracing.github.io/helm-charts
        helm repo update
        
        # Deploy WaveOps
        helm upgrade --install waveops deployment/helm/waveops \
          --namespace waveops \
          --create-namespace \
          --values deployment/helm/waveops/values-${{ matrix.environment }}.yaml \
          --set image.tag=${{ github.sha }} \
          --wait --timeout=600s
          
        # Deploy monitoring stack
        if [ "${{ matrix.environment }}" != "development" ]; then
          helm upgrade --install monitoring-stack deployment/helm/monitoring \
            --namespace monitoring \
            --create-namespace \
            --values deployment/helm/monitoring/values-${{ matrix.environment }}.yaml \
            --wait --timeout=300s
        fi
        
    - name: Verify deployment
      run: |
        kubectl wait --for=condition=available --timeout=300s deployment/waveops-coordinator -n waveops
        kubectl get pods -n waveops
        kubectl get services -n waveops
        
        # Run basic health checks
        kubectl run health-check --image=curlimages/curl --rm -i --restart=Never -- \
          curl -f http://waveops-service.waveops.svc.cluster.local/health
          
    - name: Run smoke tests
      run: |
        kubectl run smoke-test --image=curlimages/curl --rm -i --restart=Never -- \
          curl -f http://waveops-service.waveops.svc.cluster.local/api/v1/waves
          
    - name: Update deployment status
      uses: chrnorm/deployment-status@v2
      if: always()
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        state: ${{ job.status }}
        deployment-id: ${{ github.run_id }}

  # Infrastructure Drift Detection
  drift-detection:
    name: Infrastructure Drift Detection
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    strategy:
      matrix:
        environment: [development, staging, production]
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets[format('AWS_ACCESS_KEY_ID_{0}', upper(matrix.environment))] }}
        aws-secret-access-key: ${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', upper(matrix.environment))] }}
        aws-region: ${{ secrets[format('AWS_REGION_{0}', upper(matrix.environment))] }}
        
    - name: Terraform Init
      run: |
        cd deployment/terraform
        terraform init \
          -backend-config="bucket=${{ secrets[format('TF_STATE_BUCKET_{0}', upper(matrix.environment))] }}" \
          -backend-config="key=waveops/${{ matrix.environment }}/terraform.tfstate" \
          -backend-config="region=${{ secrets[format('AWS_REGION_{0}', upper(matrix.environment))] }}" \
          -backend-config="dynamodb_table=${{ secrets[format('TF_LOCK_TABLE_{0}', upper(matrix.environment))] }}"
          
    - name: Check for drift
      id: drift
      run: |
        cd deployment/terraform
        terraform plan \
          -var-file="environments/${{ matrix.environment }}.tfvars" \
          -detailed-exitcode \
          -no-color > drift-report-${{ matrix.environment }}.txt 2>&1
        echo "exit_code=$?" >> $GITHUB_OUTPUT
      continue-on-error: true
      
    - name: Create drift issue
      if: steps.drift.outputs.exit_code == '2'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const driftReport = fs.readFileSync('deployment/terraform/drift-report-${{ matrix.environment }}.txt', 'utf8');
          
          const issue = await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: 'Infrastructure Drift Detected - ${{ matrix.environment }}',
            body: `## Infrastructure Drift Detection Report
            
            **Environment:** ${{ matrix.environment }}
            **Detection Time:** ${new Date().toISOString()}
            
            Infrastructure drift has been detected in the ${{ matrix.environment }} environment.
            
            <details>
            <summary>Drift Details</summary>
            
            \`\`\`diff
            ${driftReport}
            \`\`\`
            </details>
            
            **Next Steps:**
            1. Review the detected changes
            2. Determine if changes are expected
            3. Update infrastructure code if needed
            4. Apply corrections through standard deployment process
            
            **Priority:** High
            **Labels:** infrastructure, drift, ${{ matrix.environment }}
            `,
            labels: ['infrastructure', 'drift', '${{ matrix.environment }}', 'high-priority']
          });
          
          console.log('Created drift detection issue:', issue.data.html_url);

  # Cost Analysis
  cost-analysis:
    name: Infrastructure Cost Analysis
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID_PROD }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}
        aws-region: ${{ secrets.AWS_REGION_PROD }}
        
    - name: Install cost analysis tools
      run: |
        # Install AWS CLI
        pip install awscli boto3
        
        # Install infracost
        curl -fsSL https://raw.githubusercontent.com/infracost/infracost/master/scripts/install.sh | sh
        
    - name: Run cost analysis
      env:
        INFRACOST_API_KEY: ${{ secrets.INFRACOST_API_KEY }}
      run: |
        cd deployment/terraform
        
        # Generate cost estimate for each environment
        for env in development staging production; do
          infracost breakdown \
            --path . \
            --terraform-var-file environments/${env}.tfvars \
            --format json \
            --out-file cost-${env}.json
            
          infracost output \
            --path cost-${env}.json \
            --format table \
            --out-file cost-${env}.txt
        done
        
        # Create cost comparison
        infracost diff \
          --path cost-development.json \
          --compare-to cost-production.json \
          --format table \
          --out-file cost-comparison.txt
          
    - name: Upload cost analysis reports
      uses: actions/upload-artifact@v4
      with:
        name: cost-analysis-reports
        path: deployment/terraform/cost-*.txt
        
    - name: Send cost report to Slack
      uses: 8398a7/action-slack@v3
      with:
        status: custom
        custom_payload: |
          {
            channel: '#infrastructure',
            username: 'Cost Analyzer',
            icon_emoji: ':money_with_wings:',
            attachments: [{
              color: 'warning',
              title: 'Weekly Infrastructure Cost Analysis',
              text: 'Infrastructure cost analysis completed. Check the artifacts for detailed reports.',
              fields: [{
                title: 'Repository',
                value: '${{ github.repository }}',
                short: true
              }, {
                title: 'Report Date',
                value: '$(date)',
                short: true
              }]
            }]
          }
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Cleanup
  cleanup-resources:
    name: Cleanup Resources
    runs-on: ubuntu-latest
    if: github.event.inputs.action == 'destroy'
    environment:
      name: ${{ github.event.inputs.environment }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets[format('AWS_ACCESS_KEY_ID_{0}', upper(github.event.inputs.environment))] }}
        aws-secret-access-key: ${{ secrets[format('AWS_SECRET_ACCESS_KEY_{0}', upper(github.event.inputs.environment))] }}
        aws-region: ${{ secrets[format('AWS_REGION_{0}', upper(github.event.inputs.environment))] }}
        
    - name: Terraform Init
      run: |
        cd deployment/terraform
        terraform init \
          -backend-config="bucket=${{ secrets[format('TF_STATE_BUCKET_{0}', upper(github.event.inputs.environment))] }}" \
          -backend-config="key=waveops/${{ github.event.inputs.environment }}/terraform.tfstate" \
          -backend-config="region=${{ secrets[format('AWS_REGION_{0}', upper(github.event.inputs.environment))] }}" \
          -backend-config="dynamodb_table=${{ secrets[format('TF_LOCK_TABLE_{0}', upper(github.event.inputs.environment))] }}"
          
    - name: Terraform Destroy
      run: |
        cd deployment/terraform
        terraform destroy \
          -var-file="environments/${{ github.event.inputs.environment }}.tfvars" \
          -auto-approve
          
    - name: Verify cleanup
      run: |
        echo "Infrastructure destroyed for environment: ${{ github.event.inputs.environment }}"
        echo "Please verify that all resources have been properly cleaned up in the AWS console."